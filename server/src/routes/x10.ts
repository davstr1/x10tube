import { Router, Request, Response } from 'express';
import {
  getCollectionById,
  removeItemFromCollection,
  updateCollectionTitle,
  updateCollectionPrePrompt,
  CollectionWithItems
} from '../services/collection.js';
import { getUserSettings, getDefaultPrePromptText } from '../services/settings.js';
import { config } from '../config.js';
import { asyncHandler } from '../lib/asyncHandler.js';

export const x10Router = Router();

// CORS middleware for .md endpoints (needed for extension "Copy MD Content")
x10Router.use('/*.md', (req: Request, res: Response, next) => {
  const origin = req.headers.origin;
  if (origin) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  next();
});

// Helper: Build markdown content for a collection
function buildCollectionMarkdown(collection: CollectionWithItems, collectionId: string): string {
  const defaultPrePrompt = getDefaultPrePromptText();
  const effectivePrePrompt = collection.pre_prompt || defaultPrePrompt;

  let md = '';

  // Pre-prompt
  if (effectivePrePrompt) {
    md += `${effectivePrePrompt}\n\n`;
  }

  md += `# ${collection.title || 'Untitled'}\n\n`;

  // Items list
  md += `## Items included\n\n`;
  collection.items.forEach((item, index) => {
    const isYouTube = item.source_type === 'youtube';
    const typeLabel = isYouTube ? 'YouTube' : 'Web';
    const durationPart = item.duration ? ` — ${item.duration}` : '';
    md += `${index + 1}. [${typeLabel}] ${item.title} — ${item.channel}${durationPart}\n`;
  });

  md += `\n---\n\n`;

  // Content
  const baseUrl = config.baseUrl;
  md += `## Content\n\n`;
  collection.items.forEach((item, index) => {
    const isYouTube = item.source_type === 'youtube';
    const itemId = isYouTube ? item.source_id : item.id;

    md += `### ${index + 1}. ${item.title}\n\n`;
    md += `**Type**: ${isYouTube ? 'YouTube Video' : 'Web Page'}  \n`;
    md += `**Source**: ${item.channel}  \n`;
    if (item.duration) {
      md += `**Duration**: ${item.duration}  \n`;
    }
    md += `**URL**: ${item.url}  \n`;
    md += `**MD**: ${baseUrl}/s/${collectionId}/v/${itemId}.md\n\n`;
    md += `${item.transcript}\n\n`;
    md += `---\n\n`;
  });

  // Footer
  const date = new Date(collection.created_at).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
  md += `*Generated by [${config.brandName}](${config.baseUrl}) — ${date}*\n`;

  return md;
}

// Collection page (Markdown for LLM) - Must be before /:id to match first
x10Router.get('/:id.md', asyncHandler(async (req: Request, res: Response) => {
  const id = req.params.id;
  const collection = await getCollectionById(id);

  if (!collection) {
    return res.status(404).send('# Not found\n\nThis collection does not exist.');
  }

  const md = buildCollectionMarkdown(collection, id);
  res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
  res.send(md);
}));

// Collection page (Plain text for LLM) - Alternative to .md for testing
x10Router.get('/:id.txt', asyncHandler(async (req: Request, res: Response) => {
  const id = req.params.id;
  const collection = await getCollectionById(id);

  if (!collection) {
    return res.status(404).send('Not found\n\nThis collection does not exist.');
  }

  const md = buildCollectionMarkdown(collection, id);
  res.setHeader('Content-Type', 'text/plain; charset=utf-8');
  res.send(md);
}));

// Single item MD - /s/:id/v/:itemId.md (itemId can be youtube_id or item.id)
x10Router.get('/:id/v/:itemId.md', asyncHandler(async (req: Request, res: Response) => {
  const { id, itemId } = req.params;
  const collection = await getCollectionById(id);

  if (!collection) {
    return res.status(404).send('# Not found\n\nThis collection does not exist.');
  }

  // Find item by source_id (youtube_id for YouTube) OR by item id (for web pages)
  const item = collection.items.find(v => v.source_id === itemId || v.id === itemId);
  if (!item) {
    return res.status(404).send(`# Not found\n\nItem ${itemId} does not exist in this collection.`);
  }

  const isYouTube = item.source_type === 'youtube';

  // Use collection's pre_prompt or the default (don't create user settings for public .md endpoints)
  const defaultPrePrompt = getDefaultPrePromptText();
  const effectivePrePrompt = collection.pre_prompt || defaultPrePrompt;

  // Build markdown content
  let md = '';

  // Pre-prompt
  if (effectivePrePrompt) {
    md += `${effectivePrePrompt}\n\n`;
  }

  md += `# ${item.title}\n\n`;
  md += `**Type**: ${isYouTube ? 'YouTube Video' : 'Web Page'}  \n`;
  md += `**Source**: ${item.channel}  \n`;
  if (item.duration) {
    md += `**Duration**: ${item.duration}  \n`;
  }
  md += `**URL**: ${item.url}\n\n`;
  md += `---\n\n`;
  md += `## ${isYouTube ? 'Transcript' : 'Content'}\n\n`;
  md += `${item.transcript}\n\n`;

  // Footer
  const date = new Date(collection.created_at).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
  md += `*Generated by [${config.brandName}](${config.baseUrl}) — ${date}*\n`;

  res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
  res.send(md);
}));

// Collection page (HTML)
x10Router.get('/:id', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;
  const collection = await getCollectionById(id);

  if (!collection) {
    return res.status(404).render('error', {
      title: 'Not found',
      message: 'This collection does not exist'
    });
  }

  // Format token count for display
  const tokenDisplay = collection.tokenCount > 1000
    ? `~${Math.round(collection.tokenCount / 1000)}K tokens`
    : `~${collection.tokenCount} tokens`;

  // Format date
  const createdDate = new Date(collection.created_at).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });

  // Check if current user is owner (by user_id or anonymous_id)
  const anonymousId = req.anonymousId;
  // TODO: Also check user_id when auth is implemented
  const isOwner = collection.anonymous_id === anonymousId;

  // Get user settings for default pre-prompt
  const settings = await getUserSettings(anonymousId);
  const defaultPrePrompt = getDefaultPrePromptText();

  // Determine effective pre-prompt (collection's own, or fall back to user's default)
  const effectivePrePrompt = collection.pre_prompt || settings.default_pre_prompt || defaultPrePrompt;

  res.render('x10', {
    title: collection.title || 'Untitled collection',
    x10: collection,
    tokenDisplay,
    createdDate,
    currentUser: null,
    isOwner,
    isOrphan: collection.user_id === null && collection.anonymous_id === null,
    effectivePrePrompt,
    defaultPrePrompt
  });
}));

// Helper to check if user can edit collection
function canEdit(collection: CollectionWithItems | null, anonymousId: string): boolean {
  if (!collection) return false;
  // Owner by anonymous_id
  if (collection.anonymous_id === anonymousId) return true;
  // TODO: Also check user_id when auth is implemented
  return false;
}

// DISABLED: Server-side extraction removed
// Adding content from the web page is temporarily disabled - use the Chrome extension instead
x10Router.post('/:id/add', (_req: Request, res: Response) => {
  return res.status(410).json({
    error: 'Adding content from the web is temporarily disabled. Please use the Chrome extension.',
    hint: 'Content extraction now happens client-side to avoid rate limiting.'
  });
});

// Remove item from collection
x10Router.post('/:id/remove/:videoId', asyncHandler(async (req: Request, res: Response) => {
  const { id, videoId } = req.params;

  const collection = await getCollectionById(id);
  if (!collection) {
    return res.status(404).json({ error: 'Collection not found' });
  }

  // Check ownership
  if (!canEdit(collection, req.anonymousId)) {
    return res.status(403).json({ error: 'Not authorized to edit this collection' });
  }

  const success = await removeItemFromCollection(id, videoId);
  if (success) {
    res.redirect(`/s/${id}`);
  } else {
    res.status(404).json({ error: 'Item not found' });
  }
}));

// Update collection title
x10Router.post('/:id/title', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;
  const { title } = req.body;

  const collection = await getCollectionById(id);
  if (!collection) {
    return res.status(404).json({ error: 'Collection not found' });
  }

  // Check ownership
  if (!canEdit(collection, req.anonymousId)) {
    return res.status(403).json({ error: 'Not authorized to edit this collection' });
  }

  const success = await updateCollectionTitle(id, title);
  if (success) {
    res.redirect(`/s/${id}`);
  } else {
    res.status(404).json({ error: 'Collection not found' });
  }
}));

// Update collection pre-prompt
x10Router.post('/:id/preprompt', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;
  const { prePrompt } = req.body;

  const collection = await getCollectionById(id);
  if (!collection) {
    return res.status(404).json({ error: 'Collection not found' });
  }

  // Check ownership
  if (!canEdit(collection, req.anonymousId)) {
    return res.status(403).json({ error: 'Not authorized to edit this collection' });
  }

  const success = await updateCollectionPrePrompt(id, prePrompt || null);
  if (success) {
    res.redirect(`/s/${id}`);
  } else {
    res.status(404).json({ error: 'Collection not found' });
  }
}));
